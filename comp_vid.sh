#!/bin/bash

# Default audio bitrate in bits per second (128 kbps)
AUDIO_BITRATE=128000  # 128 kbps

# Parse command-line arguments
while getopts ":i:o:f:" opt; do
  case $opt in
    i) input_filename="$OPTARG"
    ;;
    o) output_filename="$OPTARG"
    ;;
    f) desired_size_mb="$OPTARG"
    ;;
    \?) echo "Invalid option: -$OPTARG" >&2
        echo "Usage: $0 -i [input_filename] -o [output_filename] -f [desired_size_in_MB]"
        exit 1
        ;;
  esac
done

# Check if all arguments are provided
if [ -z "$input_filename" ] || [ -z "$output_filename" ] || [ -z "$desired_size_mb" ]; then
    echo "Usage: $0 -i [input_filename] -o [output_filename] -f [desired_size_in_MB]"
    exit 1
fi

# Check if input file exists
if [ ! -f "$input_filename" ]; then
    echo "Input file '$input_filename' does not exist."
    exit 1
fi

# Get the video duration in seconds (with decimal part)
duration=$(ffprobe -v error -show_entries format=duration \
-of default=noprint_wrappers=1:nokey=1 "$input_filename")

# Validate duration
if [ -z "$duration" ]; then
    echo "Could not determine video duration."
    exit 1
fi

# Get video width and height
IFS=',' read width height < <(ffprobe -v error -select_streams v:0 \
-show_entries stream=width,height -of csv=p=0:s=',' "$input_filename")

# Validate width and height
if [ -z "$width" ] || [ -z "$height" ]; then
    echo "Could not determine video width and height."
    exit 1
fi

# Calculate total bitrate in bits per second
desired_size_bits=$(echo "$desired_size_mb * 1024 * 1024 * 8" | bc)
total_bitrate=$(echo "scale=2; $desired_size_bits / $duration" | bc)

# Ensure total bitrate is greater than audio bitrate
if (( $(echo "$total_bitrate <= $AUDIO_BITRATE" | bc -l) )); then
    echo "Desired file size is too small for the video's length and audio bitrate."
    exit 1
fi

# Calculate video bitrate
video_bitrate=$(echo "$total_bitrate - $AUDIO_BITRATE" | bc)

# Convert video bitrate to kilobits per second for ffmpeg (divide by 1000)
video_bitrate_kbps=$(echo "scale=2; $video_bitrate / 1000" | bc)

# Remove existing stats files
rm -f ffmpeg2pass-0.log ffmpeg2pass-0.log.mbtree mylogfile-0.log mylogfile-0.log.mbtree

# Determine if scaling is needed
if [ "$width" -gt "$width" ] || [ "$height" -gt "$height" ]; then
    # Scale down to fit within max dimensions while preserving aspect ratio
    scale_option="-vf scale='min($width,iw)':min'($height,ih)':force_original_aspect_ratio=decrease"
else
    # No scaling needed
    scale_option=""
fi

# Execute the ffmpeg commands
ffmpeg -y -i "$input_filename" -c:v libx264 -b:v "${video_bitrate_kbps}k" \
$scale_option -pass 1 -passlogfile mylogfile -an -f null /dev/null && \
ffmpeg -i "$input_filename" -c:v libx264 -b:v "${video_bitrate_kbps}k" \
$scale_option -pass 2 -passlogfile mylogfile -c:a aac -b:a 128k "$output_filename"

# Clean up pass log files generated by ffmpeg
rm -f mylogfile-0.log mylogfile-0.log.mbtree
